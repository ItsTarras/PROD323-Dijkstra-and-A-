namespace YourUserCode
{
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;
    using Priority_Queue;
    using UnityEngine;
    using UnityEngine.Android;
    using Vector2 = System.Numerics.Vector2;

    public static class PathAlgorithm
    {
        public static float totalCost;

        // This function will return a list of nodes generated by BFS algorithm.
        // This assumes the graph is directed and unweighted meaning no costs.
        // BFS will check all nodes before returning a path
        public static List<Node> BFS(TerrainGraph tGraph, Node startNode, Node endNode)
        {
            // A list of nodes that denotes the path
            List<Node> path = new List<Node>();

            // Declare data structures to use
            Dictionary<Node, Node> visitedNodes = new Dictionary<Node, Node>();
            Queue<Node> nodesToVisit = new Queue<Node>();

            // START OF ALGORITHM IMPLEMENTATION

            // TODO: Queue to visit the starting node

            // Sets where we came from, since we start from startNode, we also came from startNode
            // The fist startNode defines the current node, the second startNode defines the source node
            // node1->node2 or visitedNodes[node2] = node1
            visitedNodes.Add(startNode, startNode);

            Node currentNode = new Node(0, 0);

            // Iterate through the rest of the nodes
            while (nodesToVisit.Count > 0)
            {
                // TODO: Visit the next node in the queue

                if (currentNode == endNode)
                {
                    break; // Already reached the end node, exit the loop
                }

                // TODO: Check if each of the current node's neighbours have been visited
                // If the neighbour hasn't been visited before, then queue it for visitation
                // After which, set the neighbour's source node to the current node, making a connection between them
                foreach (Node adjacentNode in tGraph.GetNeighbours(currentNode))
                {
                    if (!visitedNodes.ContainsKey(adjacentNode))
                    {
                        // Code goes here...
                    }
                }

                break; // TODO: Remove this break once you've filled in your code. This stops Unity from freezing.
            }

            // TODO: Construct the path, follow back the visited nodes where connections were made
            // Iterate through all visited nodes until you reach the start node working on your way back
            // Add the visited nodes to the provided path list
            while (currentNode != startNode)
            {
                // Code goes here...

                break; // TODO: Remove this break once you've filled in your code. This stops Unity from freezing.
            }
            path.Reverse();
            return path;
        }

        // This function will return a list of nodes generated by Dijkstra algorithm
        // This assumes the graph is directed and weighted meaning there are costs
        public static List<Node> Dijkstra(TerrainGraph tGraph, Node startNode, Node endNode)
        {
            // A list of nodes that denotes the path
            List<Node> path = new List<Node>();
            totalCost = 0; // For updating canvas info

            // Declare data structures to use
            Dictionary<Node, Node> visitedNodes = new Dictionary<Node, Node>();
            Dictionary<Node, float> accumulatedCost = new Dictionary<Node, float>();
            SimplePriorityQueue<Node> nodesToVisit = new SimplePriorityQueue<Node>();

            // START OF ALGORITHM IMPLEMENTATION

            // TODO: Queue to visit the starting node with a cost/priority of 0

            // Sets where we came from, since we start from startNode, we also came from startNode
            // The fist startNode defines the current node, the second startNode defines the source node
            // node1->node2 or visitedNodes[node2] = node1
            // Accumulated cost for startNode is 0
            visitedNodes.Add(startNode, startNode);
            accumulatedCost.Add(startNode, 0);

            Node currentNode = new Node(0, 0);

            // Iterate through all the nodes
            while (nodesToVisit.Count > 0)
            {
                // TODO: Visit the next node in the queue

                if (currentNode == endNode)
                {
                    break; // Already reached the end node, exit the loop
                }

                // Check if each of the current node's neighbours have been visited
                foreach (Node adjacentNode in tGraph.GetNeighbours(currentNode))
                {
                    if (!visitedNodes.ContainsKey(adjacentNode))
                    {
                        // TODO: If the neighbour has not been visited before, then calculate an estimated new cost by
                        // adding the accumulated cost of the current node and the next minimum cost of the current node (see TerrainGraph)
                        float newCost = 0;
                        
                        // Now, check if the cost of the neighbouring node has been accounted for already or
                        // if the new estimated cost is smaller than the current cost of the neighbouring node. 
                        if (!accumulatedCost.ContainsKey(adjacentNode) || newCost < accumulatedCost[adjacentNode])
                        {
                            // TODO: The accumulated cost of the neighbouring node will take the new estimated cost

                            // The neighbouring node has now been processed. Now, make a connection between the adjacent and current node
                            visitedNodes[adjacentNode] = currentNode;

                            // Enqueue the next node to visit with its cost. The priority queue will always dequeue first the node that has the smallest cost / highest priority.
                            float priority = newCost;
                            nodesToVisit.Enqueue(adjacentNode, priority);

                            totalCost = +newCost;
                        }
                    }
                }
            }

            // TODO: Construct the path, follow back the visited nodes where connections were made
            // Iterate through all visited nodes until you reach the start node working on your way back
            // Add the visited nodes to the provided path list
            while (currentNode != startNode)
            {
                // Code goes here...
            }
            path.Reverse();
            return path;
        }

        // This function will return a list of nodes generated by A* algorithm
        // This assumes the graph is directed and weighted meaning there are costs
        public static List<Node> AStar(TerrainGraph tGraph, Node startNode, Node endNode, int mode)
        {
            // A list of nodes that denotes the path
            List<Node> path = new List<Node>();
            totalCost = 0; // For updating canvas info

            // Declare data structures to use
            Dictionary<Node, Node> visitedNodes = new Dictionary<Node, Node>();
            Dictionary<Node, float> accumulatedCost = new Dictionary<Node, float>();
            SimplePriorityQueue<Node> nodesToVisit = new SimplePriorityQueue<Node>();

            // START OF ALGORITHM IMPLEMENTATION

            // TODO: Queue to visit the starting node with a cost/priority of 0

            // Sets where we came from, since we start from startNode, we also came from startNode
            // The fist startNode defines the current node, the second startNode defines the source node
            // node1->node2 or visitedNodes[node2] = node1
            // Accumulated cost for startNode is 0
            visitedNodes.Add(startNode, startNode);
            accumulatedCost.Add(startNode, 0);

            Node currentNode = new Node(0, 0);

            // Iterate through all the nodes
            while (nodesToVisit.Count > 0)
            {
                // TODO: Visit the next node in the queue

                if (currentNode == endNode)
                {
                    break; // Already reached the end node, exit the loop
                }

                // Check if each of the current node's neighbours have been visited
                foreach (Node adjacentNode in tGraph.GetNeighbours(currentNode))
                {
                    if (!visitedNodes.ContainsKey(adjacentNode))
                    {
                        // TODO: If the neighbour has not been visited before, then calculate an estimated new cost by
                        // adding the accumulated cost of the current node and the next minimum cost of the current node (see TerrainGraph)
                        float newCost = 0;

                        // Now, check if the cost of the neighbouring node has been accounted for already or
                        // if the new estimated cost is smaller than the current cost of the neighbouring node. 
                        if (!accumulatedCost.ContainsKey(adjacentNode) || newCost < accumulatedCost[adjacentNode])
                        {
                            // TODO: The accumulated cost of the neighbouring node will take the new estimated cost

                            // The neighbouring node has now been processed. Now, make a connection between the adjacent and current node
                            visitedNodes[adjacentNode] = currentNode;

                            // Calculate the heuristic value depending on the selected A* heuristic
                            float heuristicValue = 0;
                            switch (mode)
                            {
                                case 2: // Standard
                                    heuristicValue = HeuristicStandard(adjacentNode, endNode);
                                    break;
                                case 3: // Euclidian
                                    heuristicValue = HeuristicEuclidian(adjacentNode, endNode);
                                    break;
                                case 4: // Manhattan
                                    heuristicValue = HeuristicManhattan(adjacentNode, endNode);
                                    break;
                                case 5: // Diagonal
                                    heuristicValue = HeuristicDiagonal(adjacentNode, endNode);
                                    break;
                                case 6: // Octile
                                    heuristicValue = HeuristicOctile(adjacentNode, endNode);
                                    break;
                            }

                            // Add the calculated heuristic value to the new estimated cost
                            // Enqueue the next node to visit with its cost. The priority queue will always dequeue first the node that has the smallest cost / highest priority.
                            float priority = newCost + heuristicValue;
                            nodesToVisit.Enqueue(adjacentNode, priority);

                            totalCost += newCost;
                        }
                    }
                }

            }

            // TODO: Construct the path, follow back the visited nodes where connections were made
            // Iterate through all visited nodes until your reach the start node working on your way back
            // Add the visited nodes to the provided path list
            while (currentNode != startNode)
            {
                // Code goes here...
            }
            path.Reverse();
            return path;
        }

        // Standard A* heuristic. Calculate the distance between 2 nodes.
        private static float HeuristicStandard(Node a, Node b)
        {
            return Vector2.Distance(a.nodePosition, b.nodePosition);
        }

        // TODO: Euclidian distance. Calculate the straight-line distance between the x and y coordinates of two nodes. Assumes there are no obstacles.
        // This is calculated by:
        // 1. Getting the squared absolute distance between 2 nodes
        // 2. Calculating the square root of the sum of distance X and distance Y
        private static float HeuristicEuclidian(Node a, Node b)
        {
            float distX = 0f;
            float distY = 0f;

            return 0f;
        }

        // TODO: Manhattan distance. Calculate the absolute distance between the x and y coordinates of two nodes.
        // After which, get the sum of distance X and distance Y
        private static float HeuristicManhattan(Node a, Node b)
        {
            float distX = 0f;
            float distY = 0f;

            return 0f;
        }

        // TODO: Diagonal distance. Calculate the maximum absolute distances between the x and y coordinates of two nodes.
        // See Mathf.Max() function.
        private static float HeuristicDiagonal(Node a, Node b)
        {
            float distX = 0f;
            float distY = 0f;

            return 0f;
        }

        // TODO: Octile distance. Calculate the maximum and minimum absolute distances between the x and y coordinates of two nodes.
        private static float HeuristicOctile(Node a, Node b)
        {
            float distX = 0f;
            float distY = 0f;

            float diagonal = 0f; // Min
            float straight = 0f; // Max minus the diagonal movement

            return diagonal * Mathf.Sqrt(2) + straight;
        }
    }

}
