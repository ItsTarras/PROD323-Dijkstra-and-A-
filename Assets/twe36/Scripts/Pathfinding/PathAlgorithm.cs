namespace YourUserCode
{
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;
    using Priority_Queue;
    using UnityEngine;
    using UnityEngine.Android;
    using Vector2 = System.Numerics.Vector2;

    public static class PathAlgorithm
    {
        public static float totalCost;

        // This function will return a list of nodes generated by BFS algorithm.
        // This assumes the graph is directed and unweighted meaning no costs.
        // BFS will check all nodes before returning a path
        public static List<Node> BFS(TerrainGraph tGraph, Node startNode, Node endNode)
        {
            // A list of nodes that denotes the path
            List<Node> path = new List<Node>();

            // Declare data structures to use
            Dictionary<Node, Node> visitedNodes = new Dictionary<Node, Node>();
            Queue<Node> nodesToVisit = new Queue<Node>();

            // START OF ALGORITHM IMPLEMENTATION

            // TODO: Queue to visit the starting node
            nodesToVisit.Enqueue(startNode);

            // Sets where we came from, since we start from startNode, we also came from startNode
            // The fist startNode defines the current node, the second startNode defines the source node
            // node1->node2 or visitedNodes[node2] = node1
            visitedNodes.Add(startNode, startNode);

            Node currentNode = new Node(0, 0);

            // Iterate through the rest of the nodes
            while (nodesToVisit.Count > 0)
            {
                //Grab the current node.
                currentNode = nodesToVisit.Dequeue();

                if (currentNode == endNode)
                {
                    break; // Already reached the end node, exit the loop
                }

                // TODO: Check if each of the current node's neighbours have been visited
                // If the neighbour hasn't been visited before, then queue it for visitation
                // After which, set the neighbour's source node to the current node, making a connection between them
                foreach (Node adjacentNode in tGraph.GetNeighbours(currentNode))
                {
                    if (!visitedNodes.ContainsKey(adjacentNode))
                    {
                        //Add the adjacent node with the curernt node as the source.
                        //Add the adjacent node to the queue.
                        nodesToVisit.Enqueue(adjacentNode);

                        //Add the adjacent node to the current node as the source.
                        visitedNodes.Add(adjacentNode, currentNode);
                    }
                }
            }

            // TODO: Construct the path, follow back the visited nodes where connections were made
            // Iterate through all visited nodes until you reach the start node working on your way back
            // Add the visited nodes to the provided path list
            while (currentNode != startNode)
            {
                path.Add(currentNode);
                currentNode = visitedNodes[currentNode];
                
            }
            path.Reverse();
            return path;
        }

        // This function will return a list of nodes generated by Dijkstra algorithm
        // This assumes the graph is directed and weighted meaning there are costs
        public static List<Node> Dijkstra(TerrainGraph tGraph, Node startNode, Node endNode)
        {
            // A list of nodes that denotes the path
            List<Node> path = new List<Node>();
            totalCost = 0; // For updating canvas info

            // Declare data structures to use
            Dictionary<Node, Node> visitedNodes = new Dictionary<Node, Node>();
            Dictionary<Node, float> accumulatedCost = new Dictionary<Node, float>();
            SimplePriorityQueue<Node> nodesToVisit = new SimplePriorityQueue<Node>();

            // START OF ALGORITHM IMPLEMENTATION

            // TODO: Queue to visit the starting node with a cost/priority of 0
            nodesToVisit.Enqueue(startNode, 0);

            // Sets where we came from, since we start from startNode, we also came from startNode
            // The fist startNode defines the current node, the second startNode defines the source node
            // node1->node2 or visitedNodes[node2] = node1
            // Accumulated cost for startNode is 0
            visitedNodes.Add(startNode, startNode);
            accumulatedCost.Add(startNode, 0);

            Node currentNode = new Node(0, 0);

            // Iterate through all the nodes
            while (nodesToVisit.Count > 0)
            {
                // TODO: Visit the next node in the queue
                currentNode = nodesToVisit.Dequeue();

                if (currentNode == endNode)
                {
                    break; // Already reached the end node, exit the loop
                }

                // Check if each of the current node's neighbours have been visited
                foreach (Node adjacentNode in tGraph.GetNeighbours(currentNode))
                {
                    if (!visitedNodes.ContainsKey(adjacentNode))
                    {
                        // TODO: If the neighbour has not been visited before, then calculate an estimated new cost by
                        // adding the accumulated cost of the current node and the next minimum cost of the current node (see TerrainGraph)
                        float newCost = accumulatedCost[currentNode] + tGraph.NextMinimumCost(currentNode);
                        

                        // Now, check if the cost of the neighbouring node has been accounted for already or
                        // if the new estimated cost is smaller than the current cost of the neighbouring node. 
                        if (!accumulatedCost.ContainsKey(adjacentNode) || newCost < accumulatedCost[adjacentNode])
                        {
                            // TODO: The accumulated cost of the neighbouring node will take the new estimated cost
                            accumulatedCost[adjacentNode] = newCost;

                            // The neighbouring node has now been processed. Now, make a connection between the adjacent and current node
                            visitedNodes[adjacentNode] = currentNode;

                            // Enqueue the next node to visit with its cost. The priority queue will always dequeue first the node that has the smallest cost / highest priority.
                            float priority = newCost;
                            nodesToVisit.Enqueue(adjacentNode, priority);

                            totalCost = +newCost;
                        }
                    }
                }
            }

            // TODO: Construct the path, follow back the visited nodes where connections were made
            // Iterate through all visited nodes until you reach the start node working on your way back
            // Add the visited nodes to the provided path list
            while (currentNode != startNode)
            {
                path.Add(currentNode);
                currentNode = visitedNodes[currentNode];
                
            }
            path.Reverse();
            return path;
        }

        // This function will return a list of nodes generated by A* algorithm
        // This assumes the graph is directed and weighted meaning there are costs
        public static List<Node> AStar(TerrainGraph tGraph, Node startNode, Node endNode, int mode)
        {
            // A list of nodes that denotes the path
            List<Node> path = new List<Node>();
            totalCost = 0; // For updating canvas info

            // Declare data structures to use
            Dictionary<Node, Node> visitedNodes = new Dictionary<Node, Node>();
            Dictionary<Node, float> accumulatedCost = new Dictionary<Node, float>();
            SimplePriorityQueue<Node> nodesToVisit = new SimplePriorityQueue<Node>();

            // START OF ALGORITHM IMPLEMENTATION

            // TODO: Queue to visit the starting node with a cost/priority of 0
            nodesToVisit.Enqueue(startNode, 0);

            // Sets where we came from, since we start from startNode, we also came from startNode
            // The fist startNode defines the current node, the second startNode defines the source node
            // node1->node2 or visitedNodes[node2] = node1
            // Accumulated cost for startNode is 0
            visitedNodes.Add(startNode, startNode);
            accumulatedCost.Add(startNode, 0);

            Node currentNode = new Node(0, 0);

            // Iterate through all the nodes
            while (nodesToVisit.Count > 0)
            {
                // TODO: Visit the next node in the queue
                currentNode = nodesToVisit.Dequeue();


                if (currentNode == endNode)
                {
                    break; // Already reached the end node, exit the loop
                }

                // Check if each of the current node's neighbours have been visited
                foreach (Node adjacentNode in tGraph.GetNeighbours(currentNode))
                {
                    if (!visitedNodes.ContainsKey(adjacentNode))
                    {
                        // TODO: If the neighbour has not been visited before, then calculate an estimated new cost by
                        // adding the accumulated cost of the current node and the next minimum cost of the current node (see TerrainGraph)
                        float newCost = accumulatedCost[currentNode] + tGraph.NextMinimumCost(currentNode);

                        // Now, check if the cost of the neighbouring node has been accounted for already or
                        // if the new estimated cost is smaller than the current cost of the neighbouring node. 
                        if (!accumulatedCost.ContainsKey(adjacentNode) || newCost < accumulatedCost[adjacentNode])
                        {
                            // TODO: The accumulated cost of the neighbouring node will take the new estimated cost
                            accumulatedCost[adjacentNode] = newCost;
                            // The neighbouring node has now been processed. Now, make a connection between the adjacent and current node
                            visitedNodes[adjacentNode] = currentNode;

                            // Calculate the heuristic value depending on the selected A* heuristic
                            float heuristicValue = 0;
                            switch (mode)
                            {
                                case 2: // Standard
                                    heuristicValue = HeuristicStandard(adjacentNode, endNode);
                                    break;
                                case 3: // Euclidian
                                    heuristicValue = HeuristicEuclidian(adjacentNode, endNode);
                                    break;
                                case 4: // Manhattan
                                    heuristicValue = HeuristicManhattan(adjacentNode, endNode);
                                    break;
                                case 5: // Diagonal
                                    heuristicValue = HeuristicDiagonal(adjacentNode, endNode);
                                    break;
                                case 6: // Octile
                                    heuristicValue = HeuristicOctile(adjacentNode, endNode);
                                    break;
                            }

                            // Add the calculated heuristic value to the new estimated cost
                            // Enqueue the next node to visit with its cost. The priority queue will always dequeue first the node that has the smallest cost / highest priority.
                            float priority = newCost + heuristicValue;
                            nodesToVisit.Enqueue(adjacentNode, priority);

                            totalCost += newCost;
                        }
                    }
                }

            }

            // TODO: Construct the path, follow back the visited nodes where connections were made
            // Iterate through all visited nodes until your reach the start node working on your way back
            // Add the visited nodes to the provided path list
            while (currentNode != startNode)
            {
                path.Add(currentNode);
                currentNode = visitedNodes[currentNode];
                
            }
            path.Reverse();
            return path;
        }

        // Standard A* heuristic. Calculate the distance between 2 nodes.
        private static float HeuristicStandard(Node a, Node b)
        {
            return Vector2.Distance(a.nodePosition, b.nodePosition);
        }

        // TODO: Euclidian distance. Calculate the straight-line distance between the x and y coordinates of two nodes. Assumes there are no obstacles.
        // This is calculated by:
        // 1. Getting the squared absolute distance between 2 nodes
        // 2. Calculating the square root of the sum of distance X and distance Y
        private static float HeuristicEuclidian(Node a, Node b)
        {
            float distX = Mathf.Abs(a.nodePosition.X - b.nodePosition.X);
            float distY = Mathf.Abs(a.nodePosition.Y - b.nodePosition.Y);

            float eucDistance = Mathf.Pow(distX, 2) + Mathf.Pow(distY, 2);
            float finalDistance = Mathf.Sqrt(eucDistance);

            return finalDistance;
        }

        // TODO: Manhattan distance. Calculate the absolute distance between the x and y coordinates of two nodes.
        // After which, get the sum of distance X and distance Y
        private static float HeuristicManhattan(Node a, Node b)
        {
            float distX = Mathf.Abs(a.nodePosition.X - b.nodePosition.X);
            float distY = Mathf.Abs(a.nodePosition.Y - b.nodePosition.Y);

            return Mathf.Sqrt(distX + distY);
        }

        // TODO: Diagonal distance. Calculate the maximum absolute distances between the x and y coordinates of two nodes.
        // See Mathf.Max() function.
        private static float HeuristicDiagonal(Node a, Node b)
        {
            float distX = Mathf.Abs(a.nodePosition.X - b.nodePosition.X);
            float distY = Mathf.Abs(a.nodePosition.Y - b.nodePosition.Y);

            return Mathf.Max(distX, distY);
        }

        // TODO: Octile distance. Calculate the maximum and minimum absolute distances between the x and y coordinates of two nodes.
        private static float HeuristicOctile(Node a, Node b)
        {
            float distX = Mathf.Abs(a.nodePosition.X - b.nodePosition.X);
            float distY = Mathf.Abs(a.nodePosition.Y - b.nodePosition.Y);

            float diagonal = Mathf.Min(distX, distY); // Min
            float straight = Mathf.Max(distX, distY) - diagonal; // Max minus the diagonal movement

            return diagonal * Mathf.Sqrt(2) + straight;
        }
    }

}
